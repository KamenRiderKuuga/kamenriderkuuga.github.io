<!doctype html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="浅谈WebAssembly" /><meta name="author" content="HANABI" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="WebAssembly作为新的前端标准之一，在前端有着举足轻重的地位，它到底是一种什么技术，它的过去，未来到底是什么样子，在这里做一些总结和介绍，主要介绍思路和相关示例来自于WebAssembly for Web Developers (Google I/O ’19)和Rust, WebAssembly, and the future of Serverless by Steve Klabnik" /><meta property="og:description" content="WebAssembly作为新的前端标准之一，在前端有着举足轻重的地位，它到底是一种什么技术，它的过去，未来到底是什么样子，在这里做一些总结和介绍，主要介绍思路和相关示例来自于WebAssembly for Web Developers (Google I/O ’19)和Rust, WebAssembly, and the future of Serverless by Steve Klabnik" /><link rel="canonical" href="https://lambda.cyou//posts/webassembly-1/" /><meta property="og:url" content="https://lambda.cyou//posts/webassembly-1/" /><meta property="og:site_name" content="HANABI" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-09-21T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="浅谈WebAssembly" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@HANABI" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"HANABI"},"dateModified":"2020-09-21T00:00:00+08:00","datePublished":"2020-09-21T00:00:00+08:00","description":"WebAssembly作为新的前端标准之一，在前端有着举足轻重的地位，它到底是一种什么技术，它的过去，未来到底是什么样子，在这里做一些总结和介绍，主要介绍思路和相关示例来自于WebAssembly for Web Developers (Google I/O ’19)和Rust, WebAssembly, and the future of Serverless by Steve Klabnik","headline":"浅谈WebAssembly","mainEntityOfPage":{"@type":"WebPage","@id":"https://lambda.cyou//posts/webassembly-1/"},"url":"https://lambda.cyou//posts/webassembly-1/"}</script><title>浅谈WebAssembly | HANABI</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="HANABI"><meta name="application-name" content="HANABI"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"> <img src="/assets/link.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"> </a><h1 class="site-title"> <a href="/">HANABI</a></h1><p class="site-subtitle fst-italic mb-0">可乐说自己是好猫</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>归档</span> </a><li class="nav-item"> <a href="/read/" class="nav-link"> <i class="fa-fw fas fa-book-reader"></i> <span>札记</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/KamenRiderKuuga" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github-alt"></i> </a> <a href="javascript:location.href = 'mailto:' + ['wpfmaker','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>浅谈WebAssembly</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 文章</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>浅谈WebAssembly</h1><div class="post-meta text-muted"> <span> 发表于 <time data-ts="1600617600" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2020/09/21 </time> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="5307 字" > <em>29 分钟</em>阅读</span></div></div></header><div class="content"><blockquote><p>WebAssembly作为新的前端标准之一，在前端有着举足轻重的地位，它到底是一种什么技术，它的过去，未来到底是什么样子，在这里做一些总结和介绍，主要介绍思路和相关示例来自于<a href="https://youtu.be/njt-Qzw0mVY">WebAssembly for Web Developers (Google I/O ’19)</a>和<a href="https://youtu.be/CMB6AlE1QuI">Rust, WebAssembly, and the future of Serverless by Steve Klabnik</a></p></blockquote><h2 id="web前端发展史"><span class="me-2">Web前端发展史</span><a href="#web前端发展史" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>要了解WebAssembly，就不得不从前端的发展史来讲起。网络的发展是非常漫长的，最开始的时候，我们有了HTML(<em>Tim Berners-Lee和同事Daniel W. Connolly创立于1990</em> )，可以显示一些静态的文档。但是我们并不满意，所以CSS(<em>Håkon Wium Lie创立于1994</em>)出现了，我们可以给网页添加一些样式。接着，我们想要用一些动作来控制网页，所以JavaScript出现了。</p><pre><code class="language-mermaid">graph LR
	HTML--&gt;CSS--&gt;JavaScript
</code></pre><h3 id="javascript"><span class="me-2">JavaScript</span><a href="#javascript" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>说到这里，我们不得不谈论一下JavaScript。</p><p>Web从来都是野心勃勃的，从纯文本到JavaScript，给了我们无尽的幻想，其发展大大扩展了网络作为一个供我们交互的平台的功能。我们打开电脑，打开浏览器，通过浏览器提供的Web应用和大家进行交流，浏览器就像一个小型的操作系统。一直以来，开发者们穷尽自己的想象力，想把网络推向极限，让我们可以在浏览器上面做更多想做的事情</p><p>从另一个角度想，实际上，我们现在有那么多的手机端的APP，和各种桌面应用程序，也是因为想象力不够，或者妥协的结果。试想一下，如果所有现有的APP，桌面软件都可以通过Web的形式使用，是否才是网络的最终形态呢，互联网就好像一个USB一样，随时和我们的电脑连接，不需要各种繁琐的安装，注册表，等等一切</p><p>那么，是什么阻挡了我们的想象力呢，是不思进取的<code class="language-plaintext highlighter-rouge">IE</code>，还是一心搞应用商店的苹果？这些都可以算得上是因素之一，但是从技术上来说主要原因，还是性能</p><p><strong>Javascript ，是1995年<em>Brendan Eich</em>用10天的时间设计出来的</strong>，设计这个语言当时只是公司的任务，他也没想到这个语言未来会成为互联网最流行的语言，不然可能会更用心一点设计？</p><h4 id="javascript为什么会成功"><span class="me-2">Javascript为什么会成功</span><a href="#javascript为什么会成功" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>碰瓷(误)；<li>设计理念很简单，就是易学易用</ol><h4 id="javascript的缺点"><span class="me-2">Javascript的缺点</span><a href="#javascript的缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>解释型语言，非常慢，随着前端的发展，网页应用越来越复杂，解释型语言在性能方面存在劣势。</p><h4 id="v8和asmjs"><span class="me-2">V8和asm.js</span><a href="#v8和asmjs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>随着Google在2008引入了V8引擎，才有了JS现在JIT(Just-in-time)的概念，思想就是，解释型语言，如果要运行多次，肯定就有优化的空间，于是V8就偷偷帮你编译好，在下一次运行的时候，直接执行编译好的代码。但是由于JS动态类型的特点，很多时候反而会造成负优化(JS被编译成错误的字节码，不得不重新编译的情况 )</p><p>2013年，一个来自<code class="language-plaintext highlighter-rouge">Mozilla</code>，也就是那个开发火狐浏览器的公司，发布了<code class="language-plaintext highlighter-rouge">asm.js</code>项目，这也是很有野心，也相当成功的尝试之一</p><blockquote><p><strong>asm.js</strong>是一个<a href="https://zh.wikipedia.org/wiki/中間語言">中间语言规范</a>，设计目的是使采用<a href="https://zh.wikipedia.org/wiki/C语言">C</a>等<a href="https://zh.wikipedia.org/wiki/编程语言">编程语言</a>编写的<a href="https://zh.wikipedia.org/wiki/计算机软件">计算机软件</a>可运行为<a href="https://zh.wikipedia.org/wiki/网络应用程序">网络应用程序</a>，同时性能特征明显优于标准<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>。</p></blockquote><p>asm.js通常不直接编写，而是作为一种通过<a href="https://zh.wikipedia.org/wiki/编译器">编译器</a>生成的中间语言，该编译器获取<a href="https://zh.wikipedia.org/wiki/C%2B%2B">C++</a>或其他语言的源代码，然后输出asm.js。</p><p>例如，提供下列C语言代码：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Emscripten将输出下列JavaScript代码：</p><div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nf">f</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">i</span> <span class="o">=</span> <span class="nx">i</span><span class="o">|</span><span class="mi">0</span><span class="p">;</span>
  <span class="k">return </span><span class="p">(</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>对人类来说，这些或操作可能是无操作，但是对于编译器来说，这些按位运算符可以说明操作数的类型，并给出整数结果。经过这些转换之后，优化编译器才能提前生成高效的本地代码，保证定义的是32位整数，而不是浮点数(其实不难发现，现在很多人将不同的语言：<code class="language-plaintext highlighter-rouge">jsx</code>，<code class="language-plaintext highlighter-rouge">ts</code>等编译成<code class="language-plaintext highlighter-rouge">js</code>，以此来解决在使用原生<code class="language-plaintext highlighter-rouge">js</code>开发的时候可能遇到的问题，<code class="language-plaintext highlighter-rouge">js</code>有成为前端汇编语言的趋势，这说法可能有些滑稽，但事实正是在这样发展)。</p><p>可以看得出，这样的写法很hack，有点像在滥用语义获取整数，而且事实上，只有一小部分代码适用这种优化，但即便如此，<code class="language-plaintext highlighter-rouge">js</code>的性能也得到了大幅提升。由于<code class="language-plaintext highlighter-rouge">asm.js</code>的诞生，我们有了诸如https://blog.mozilla.org/blog/2014/03/12/mozilla-and-epic-preview-unreal-engine-4-running-in-firefox/z这样的成果，虽然画质在今天看来不算特别好，但仍然是非常了不起的成就，<code class="language-plaintext highlighter-rouge">asm.js</code>大幅提高了<code class="language-plaintext highlighter-rouge">js</code>的运算能力(画面是通过WebGL来实现的，这是一套JavaScript API，使用它不需要任何插件就能在任何兼容的浏览器上渲染交互式的3D和2D图形，其是OpenGL的一个子集)</p><p>此时用到的编译器是Emscipten，也是Mozilla做的，当需要一些只能在非Web环境上调用的内容时，比如前面提到的OpenGL，或者fileopen功能等，Emscipten可以用WebGL伪装成OpenGL，也可以通过模拟一个文件系统，使你好像在处理真实的文件(意思是在编译的时候额外编译一些需要使用的文件进去，让执行代码的时候可以读取它们，并不代表可以随意打开本地文件)，几乎相当于是真的模拟了一套POSIX操作系统来让代码运行在Web上 ，而这些代码最开始不是为了Web编写的</p><h2 id="webassemlby"><span class="me-2">WebAssemlby</span><a href="#webassemlby" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>所以这次，发展方向改变了，为什么要大费周章用C/C++编译成js，再用JIT去翻译，直接给字节码不好吗？</p><p>终于有一次，四大浏览器厂商，谷歌、微软、苹果和Mozilla一致决定，不能再这样下去了，从立项开始，花费几年的时间，在2019年的12月5日，W3C宣布，继 HTML、CSS 和 JavaScript 之后，WebAssembly成为 Web 的第四语言，也就是我们今天要谈论的主角</p><p>当你使用任何语言编写代码并将其编译到WebAssembly时，这些代码会被编译成浏览器可以执行的指令集，然后这些指令集以二进制格式存储到<code class="language-plaintext highlighter-rouge">.wasm</code>文件中</p><p><a href="/assets/img/webassembly-1.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-1.PNG" alt="" loading="lazy"></a></p><p>想象一下，像<code class="language-plaintext highlighter-rouge">AutoCAD</code>这样的软件，正在移植到WebAssembly，当你想用它时，可以理解在浏览器上运行它，多么不可思议，另外Unity游戏引擎，还有虚幻引擎，都开始支持WebAssembly，通常这些游戏引擎已经内建了一套抽象，用于编译到PlayStation，XBox或其他游戏平台，现在WebAssembly就可以直接使用这些代码，并且提供所需要的性能，这是在<code class="language-plaintext highlighter-rouge">asm.js</code>时期不敢想的</p><p>还有一个例子，我们做了一个网页，在网页中让用户扫描二维码，并且识别二维码中的内容，识别二维码这个功能(图形检测API)是有些浏览器内置的，当遇到你的浏览器不支持的时候，他们就会把二维码库编译到WebAssembly上，就可以按需加载，实现这一功能，可以看到，通过WebAssembly，我们获得了浏览器本身没有的功能</p><p>另外还有UI工具包QT宣布，他们现在也支持WebAssembly了https://www.qt.io/qt-examples-for-webassembly</p><p>当使用C++时，用到的编译器是仍然还是Emscripten，它替代C/C++编译器，不将代码编译成本地机器码，而是直接编译到WebAssembly，大家可能还记得我们在前文提到过它，将C/C++编译成符合<code class="language-plaintext highlighter-rouge">asm.js</code>标准的JavaScript代码，这次，Emscripten不用编译成JavaScript，而是直接编译成WebAssembly，此时，有了这一套完整的工具链，我们就能围绕WebAssembly做更多成熟并且令人印象深刻的工具，这也是为什么WebAssembly与C++如此紧密的缘故</p><p>可能你会说，我就是一个普通的前端开发人员，前端生态已经够让人头大了，我必须要学习C++才能用这个对吗，答案是，No！因为很明显，这两种语言的差别还是挺大的，不从语言的好坏难易来评价，就从编程习惯和思想来说，相差也不是一点。而且即使这两种语言都写得很专业的人，在开发过程中不断切换也是会花费一些成本的，对于Web开发人员来说，更加没有去学习C++的动力了。这样一想，WebAssembly似乎是一个非常小众的技术</p><h4 id="webassembly到底拿来做什么"><span class="me-2">WebAssembly到底拿来做什么</span><a href="#webassembly到底拿来做什么" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>这里我们从两个方面来讨论这个疑惑，首先我们讨论JS应用中微小模块的替换</p><p>JS生态非常庞大，近些年甚至由于技术栈和一些愿意尝鲜的人的原因，已经出现了很多JS开发的桌面应用，但很明显，不是每个主题和功能的首选都是JavaScript，所以很多时候你可能面临一个问题，你需要库去解决这些问题，你可以在C或者Rust中找到这些答案，但不是在JavaScript中。因此，你要么坐下来编写自己的JavaScript实现，要么通过WebAssembly来使用其他语言的相关实现，比如<a href="https://squoosh.app/">SQuoosh</a>，这是一个完全在浏览器中运行的图像压缩应用程序，可以在脱机状态下工作，放入图片，然后用不同的编解码器压缩它们，可以从这里观察到不同的编解码器对图片质量产生不同的影响。如果比较了解的话，可以知道现代浏览器已经可以通过<code class="language-plaintext highlighter-rouge">Canvas</code>实现这个功能了，但事实证明，实现的效果不尽人意，而且，会受浏览器支持的编解码器的约束，所以一直到很长一段时间，也只有Chrome可以编码为WebP格式，其他浏览器却没有。</p><p>我们用浏览器搜索，找到了一些使用JS有关的JPEG的编解码器，但是却没有找到专门针对WebP的编码器，所以我们从其他方向查阅了一番，发现C/C++有大量相关编码器，因此，我们选择WebAssembly，将相应的库编译到WebAssembly上，并加载到浏览器中，然后使用我们自己加载的这个编解码器来处理图片，从而完成图像压缩。并且，我们的库提供了更专业或者说更细致化的功能定制，这些显然是浏览器自带的功能不会暴露给我们的。这整个过程的重点是，我们使用了一段旧代码，它绝对不是以Web为目的写的，但是我们还是将它使用在了Web上，并用来改善Web平台</p><p>具体我们是怎么做的呢，首先我们使用Emscripten来编译这个库，以便之后可以链接到它(注意，图片编解码通常是一个高并发任务，但是由于不论是JS或是WebAssembly都还不支持多线程，所以我们禁用它)， 编译完成后，除了<code class="language-plaintext highlighter-rouge">.wasm</code>文件之外，我们还会得到一个<code class="language-plaintext highlighter-rouge">.js</code> 桥接代码，用来调用编译好的<code class="language-plaintext highlighter-rouge">.wasm</code>文件，这所有的步骤，编译器都会帮你完成</p><p><a href="/assets/img/webassembly-2.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-2.PNG" alt="" loading="lazy"></a></p><p>另外值得一提的是，这个应用的Resize功能使用的图像缩放算法，实际上是来自于Rust生态，对于Rust程序员来说，可以使用<code class="language-plaintext highlighter-rouge">wasm-pack</code>将Rust代码转化为WebAssembly模块，并且生成的文件非常小，在这里比较大小有点有失公平，因为本来它们都是两个不一样的库，但是就平均而言，Rust通常会产生更小的文件，因为Rust没有做任何关于POSIX的文件系统模拟，所以不能在Rust代码中使用文件相关操作(如果想要的话，也可以使用封装好的模块，所以这个功能是可配置的，比较灵活 )</p><p><a href="/assets/img/webassembly-3.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-3.PNG" alt="" loading="lazy"></a></p><p><a href="/assets/img/webassembly-4.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-4.PNG" alt="" loading="lazy"></a></p><p>从这一整个工具中我们可以看到，我们使用了至少来自两种不同语言的四个不同的库，即使这它们跟Web无关，我们还是在Web上使用了它们，并且工作得很好。所以你看，如果我们在Web平台上发现一个技术上的空白，但是在其它语言已经实现了很多次，你应该想到WebAssembly是一个可能的工具。所以WebAssembly出现的目的，至少到目前为止的目的，不是为了取代JS，而是为了和JS配合，完整Web生态</p><p><a href="/assets/img/webassembly-5.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-5.PNG" alt="" loading="lazy"></a></p><p>接着让我们关注性能，首先，JavaScript和WebAssembly都有相同的峰值性能，但是在运行已经编译好的比较稳定的代码这点上，使用WebAssembly比Javascript快得多，因为JavaScript是弱类型的，在编译过程中容易出现一些意外情况，是编译器无法捕捉的，并且WebAssembly技术团队正在寻找多线程和SIMD技术的解决方案，由于语言的限制，这些是JavaScript永远无法做到的</p><p>为了体会什么叫”运行已经编译好的比较稳定的代码”这一点，我们来比较两者的入口</p><p><a href="/assets/img/webassembly-6.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-6.PNG" alt="" loading="lazy"></a></p><p>Ignition是一个解释器</p><p>虽然我们不能以偏概全的说机器码永远比解释型语言代码跑得更快，但就大多数情况而言，确实是这样，对于js而言，优化编译器总是只会在最后启动，也就是说只有当JS代码运行的时候才能进行优化，假设编译出来的代码没有包含所有情况，就必须再回到解释器，这被我们称为负优化，有了WebAssembly之后，我们的步骤永远都是从编译器到Turbofan</p><p>当然这边有一些来自网络的图表数据，来证明相同情况下它们速度的对比，但是我们重点想要说的是，因为js的动态类型特性，导致它速度的不稳定性，而且对于不同的浏览器，其对js的优化可能也不完全相同，在不同浏览器中的表现可能差距很大，而WebAssembly总是能带来我们想要的稳定性，这才是最重要的，这也是我们想说的，最优性能</p><p>另外，如果前端想要编写WebAssembly程序的话，他们也可以用AssemblyScript，它是完全基于TypeScript语法的，这意味着现有的前端人员也完全不需要学习一门全新的语言来使用WebAssembly</p><p>他们并不是竞争对手，但是不存在谁取代谁的关系，他们应该协作使用，至少目前是如此</p><h2 id="rust"><span class="me-2">Rust</span><a href="#rust" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>带点私心的，让我们谈论一下Rust</p><p>Rust：A language empowering everyone to build reliable and efficient software.</p><p><a href="https://baike.baidu.com/item/Rust语言/9502634?fr=aladdin">https://baike.baidu.com/item/Rust%E8%AF%AD%E8%A8%80/9502634?fr=aladdin</a></p><p>Rust是一种系统级的编程语言，其最早是Mozilla在开发Firefox时用来作为C++的替代品，意在减少语言带来的安全漏洞(大部分来自于内存安全方面，由于错误使用指针)</p><p>以往在考虑编程语言时，往往要在效率Speed和Safety之间做抉择，以往的编程语言曾经在速度上非常惊人，并且根本不关心安全性，这是因为以前计算机运行缓慢，我们要尽力用完每一部分可以利用的资源</p><p>微软的CVE(Common Vulnerabilities &amp; Exposures通用漏洞披露)，深蓝色是内存安全相关问题，浅蓝色是所有其它问题，当然这不是针对C/C++，很多高级语言延伸到低级语言以提高速度，所以你还是有很大概率会面对内存安全的问题</p><p><a href="/assets/img/webassembly-7.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-7.PNG" alt="" loading="lazy"></a></p><p>拿汇编语言来说，汇编太危险了，所以创造了C，其拥有更高的级别，虽然会获得更少的效率上的收益，但是可以增加安全性，让开发者更难编写不正确的程序</p><p>GC机制让运行时自动为我们完成内存分配和释放相关的工作，但是问题也随之而来，它会让语言的效率降低，所以我们需要在速度和安全性之间进行权衡</p><p>我们可以选择像Ruby这样很容易安全使用但是效率低下的语言，或者选择相对效率高，但是需要认为考虑很多情况，相对危险的C/C++</p><p>我们能不能同时拥有两者呢，对于Rust来说，Yes</p><p>对于Rust来说，权衡的结果是学习起来会更加困难，并且你可能会遇到许多编译器错误，因为编译器非常严格</p><p><a href="/assets/img/webassembly-8.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-8.PNG" alt="" loading="lazy"></a></p><p>从垃圾收集器，我们得到了一个概念，运行时(浅灰色代表我们自己的代码，深灰色可以看成是运行时代码)，这意味着在程序运行的时候，语言会把实际上没有编写的程序放进程序中，当使用JavaScript的时候，我们用的是V8引擎</p><p><a href="/assets/img/webassembly-9.PNG" class="popup img-link shimmer"><img src="/assets/img/webassembly-9.PNG" alt="" loading="lazy"></a></p><blockquote><h3 id="rust-有运行时吗"><span class="me-2"><a href="https://prev.rust-lang.org/zh-CN/faq.html#does-rust-have-a-runtime">Rust 有运行时吗？</a></span><a href="#rust-有运行时吗" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>没有像 Java 语言这样典型意义上的运行时。但 Rust 标准库的一部分可以被认为是一个「运行时」，它提供了堆（heap），回溯（backtraces），展开（unwinding）和栈保护（stack guards）。在用户的 <code class="language-plaintext highlighter-rouge">main</code> 函数之前只运行<a href="https://github.com/rust-lang/rust/blob/33916307780495fe311fe9c080b330d266f35bfb/src/libstd/rt.rs#L43">很少的初始化代码</a>。Rust 标准库还链接到 C 标准库，执行类似的<a href="http://www.embecosm.com/appnotes/ean9/html/ch05s02.html">运行时初始化</a>。 Rust 代码可以在没有标准库的情况下编译，在这种情况下，运行时大概相当于 C。</p></blockquote><p>所以很有趣的一点就是，Rust的问题，很多都是编译时候的问题，即使从来没有用过C/C++的人，想编写底层软件，也不会造成那么可怕的后果，所以不难明白，为什么Rust和WebAssembly有着密切的关系了吧。Rust真的非常优秀，作为一名喜欢Rust的程序员，非常希望更多人也来感受Rust带来的安全性和效率</p><h2 id="webassembly的未来"><span class="me-2">WebAssembly的未来</span><a href="#webassembly的未来" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>随着浏览器的发展，还有WebAssembly生态以及特性(多线程，操作DOM)等不断健壮，我们可以大胆猜测在不久的未来，它会在Web领域占据举足轻重的地位。甚至可以试想，在带宽和电脑性能不断增强的今天，是否以后我们可以不用下载任何其他应用软件，就在浏览器里使用各种WebAssembly编写的工具，甚至直接玩画质更加优秀的游戏呢？这值得期待</p><p>结尾可能有点草率，哈哈哈，未来趋势这个东西谁也说不好，一个技术未来会不会火也不全取决于它好或者不好，创新性，不可替代性，易用性，所在的生态圈等非常多的因素都会对它未来的发展造成影响。但还是想说，我看好WebAssembly的未来</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">前端知识</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/webassembly/" class="post-tag no-text-decoration" >WebAssembly</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted me-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%E6%B5%85%E8%B0%88WebAssembly%20-%20HANABI&url=https%3A%2F%2Flambda.cyou%2F%2Fposts%2Fwebassembly-1%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter" > <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%E6%B5%85%E8%B0%88WebAssembly%20-%20HANABI&u=https%3A%2F%2Flambda.cyou%2F%2Fposts%2Fwebassembly-1%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook" > <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=%E6%B5%85%E8%B0%88WebAssembly%20-%20HANABI&url=https%3A%2F%2Flambda.cyou%2F%2Fposts%2Fwebassembly-1%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram" > <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="分享链接" data-title-succeed="链接已复制！" > <i class="fa-fw fas fa-link pe-none"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/net-core/">.NET Core</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">Python</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%8A%80%E6%9C%AF%E5%A4%87%E5%BF%98/">技术备忘</a> <a class="post-tag btn btn-outline-primary" href="/tags/css/">CSS</a> <a class="post-tag btn btn-outline-primary" href="/tags/html/">HTML</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">Rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/">日常工具</a> <a class="post-tag btn btn-outline-primary" href="/tags/dbms/">DBMS</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">Docker</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">文章内容</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">相关文章</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/html-1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1594224000" data-df="YYYY/MM/DD" > 2020/07/09 </time><h4 class="pt-0 my-2">Head First HTML与CSS(第二版)学习笔记(HTML相关)</h4><div class="text-muted"><p> 开始学习HTML和CSS，以这本书为敲门砖，主要总结一些比较重点的知识，有必要的代码会敲一遍，在文章的源码中可以体现出来 认识HTML 好吧，本来总结了挺多，没想到书里的章节末尾已经总结的比较详细了，而且关于这里确实没有太需要解释的地方，这里直接采用读一边书，然后摘抄一遍书里总结的内容的方式来加深印象 HTML和CSS是我们用来创建网页的语言 Web服务器存储...</p></div></div></a></article><article class="col"> <a href="/posts/html-2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1594483200" data-df="YYYY/MM/DD" > 2020/07/12 </time><h4 class="pt-0 my-2">Head First HTML与CSS(第二版)学习笔记(HTML+CSS)</h4><div class="text-muted"><p> 前面对HTML基础知识做了了解，之后会结合CSS来构建，点此查看示例页面，因为HTML和CSS更多只是用来描述网页，涉及到需要理解的东西比较少，这里更多的只是读书笔记，会在示例页面中使用这里接触到的内容 加一点样式：开始学习CSS CSS包含一些简单语句，称为规则。 每个规则为选择的一些HTML元素提供样式。 典型的规则包括一个选择器，以及一个或多个属性和值。 ...</p></div></div></a></article><article class="col"> <a href="/posts/html-3/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1594742400" data-df="YYYY/MM/DD" > 2020/07/15 </time><h4 class="pt-0 my-2">关于HTML - 元素的布局与定位(float，绝对定位，CSS表格)</h4><div class="text-muted"><p> 在对HTML元素，CSS样式的基础有了解之后，终于到了激动人心的布局与定位的时候了，这里光是看文字不容易理解，会在这里展示布局的方式和过程，并把示例直接写在这里 需求 现在想通过一些布局知识，仿制一个博客园这样的布局，可以看到其大体分为四个部分，上面的导航栏，左下方的文章列表及摘要，右下方的公告，以及悬浮在界面上的小火箭组成，在那之前，先让我们来了解一些知识 流(Flow)...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/tips-3/" class="btn btn-outline-primary" aria-label="上一篇" ><p>五笔输入法学习笔记</p></a> <a href="/posts/jekyll-3/" class="btn btn-outline-primary" aria-label="下一篇" ><p>Jekyll功能扩展(mermaid,MathJax)</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p> © <time>2024</time> <a href="https://github.com/KamenRiderKuuga">HANABI</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。" >保留部分权利。</span></p><p>本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/net-core/">.NET Core</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">Python</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%8A%80%E6%9C%AF%E5%A4%87%E5%BF%98/">技术备忘</a> <a class="post-tag btn btn-outline-primary" href="/tags/css/">CSS</a> <a class="post-tag btn btn-outline-primary" href="/tags/html/">HTML</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">Rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/">日常工具</a> <a class="post-tag btn btn-outline-primary" href="/tags/dbms/">DBMS</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">Docker</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/zh.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js,npm/mermaid@10.5.0/dist/mermaid.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/unregister.js"></script> <script type="text/javascript"> (function () { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === 'undefined') { return; } let expectedTheme = mode === ModeToggle.DARK_MODE ? 'dark' : 'default'; let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $('.mermaid').each(function () { let svgCode = $(this).prev().children().html(); $(this).removeAttr('data-processed'); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, '.mermaid'); } } let initTheme = 'default'; const html = document.documentElement; if ( (html.hasAttribute('data-mode') && html.getAttribute('data-mode') === 'dark') || (!html.hasAttribute('data-mode') && window.matchMedia('(prefers-color-scheme: dark)').matches) ) { initTheme = 'dark'; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Create mermaid tag */ document.querySelectorAll('pre>code.language-mermaid').forEach((elem) => { const svgCode = elem.textContent; const backup = elem.parentElement; backup.classList.add('unloaded'); /* create mermaid node */ let mermaid = document.createElement('pre'); mermaid.classList.add('mermaid'); const text = document.createTextNode(svgCode); mermaid.appendChild(text); backup.after(mermaid); }); mermaid.initialize(mermaidConf); window.addEventListener('message', updateMermaid); })(); </script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
