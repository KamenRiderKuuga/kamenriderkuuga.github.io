<!doctype html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="theme-color" media="(prefers-color-scheme: light)" content="#f7f7f7"><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#1b1b1e"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, user-scalable=no initial-scale=1, shrink-to-fit=no, viewport-fit=cover" ><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content=".NET Core前后端分离(5) - IOC(控制反转)与DI(依赖注入)" /><meta name="author" content="HANABI" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="准备好了所有的层，那么要如何办到在各个Service层中直接调用IRepository层，并控制调用的仓储层实例的生命周期呢，之前写在各构造函数中的参数是如何获得的呢，让我们来了解IoC(Inversion of Control)以及DI(Dependence Injection)这两个概念" /><meta property="og:description" content="准备好了所有的层，那么要如何办到在各个Service层中直接调用IRepository层，并控制调用的仓储层实例的生命周期呢，之前写在各构造函数中的参数是如何获得的呢，让我们来了解IoC(Inversion of Control)以及DI(Dependence Injection)这两个概念" /><link rel="canonical" href="https://lambda.cyou//posts/dotnetcore-6/" /><meta property="og:url" content="https://lambda.cyou//posts/dotnetcore-6/" /><meta property="og:site_name" content="HANABI" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-06-20T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content=".NET Core前后端分离(5) - IOC(控制反转)与DI(依赖注入)" /><meta name="twitter:site" content="@twitter_username" /><meta name="twitter:creator" content="@HANABI" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"HANABI"},"dateModified":"2020-06-20T00:00:00+08:00","datePublished":"2020-06-20T00:00:00+08:00","description":"准备好了所有的层，那么要如何办到在各个Service层中直接调用IRepository层，并控制调用的仓储层实例的生命周期呢，之前写在各构造函数中的参数是如何获得的呢，让我们来了解IoC(Inversion of Control)以及DI(Dependence Injection)这两个概念","headline":".NET Core前后端分离(5) - IOC(控制反转)与DI(依赖注入)","mainEntityOfPage":{"@type":"WebPage","@id":"https://lambda.cyou//posts/dotnetcore-6/"},"url":"https://lambda.cyou//posts/dotnetcore-6/"}</script><title>.NET Core前后端分离(5) - IOC(控制反转)与DI(依赖注入) | HANABI</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="HANABI"><meta name="application-name" content="HANABI"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/jekyll-theme-chirpy.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tocbot@4.21.2/dist/tocbot.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return 'mode'; } static get MODE_ATTR() { return 'data-mode'; } static get DARK_MODE() { return 'dark'; } static get LIGHT_MODE() { return 'light'; } static get ID() { return 'mode-toggle'; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener('change', () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia('(prefers-color-scheme: dark)'); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { document.documentElement.setAttribute(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { document.documentElement.removeAttribute(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage( { direction: ModeToggle.ID, message: this.modeStatus }, '*' ); } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.notify(); } /* flipMode() */ } /* ModeToggle */ const modeToggle = new ModeToggle(); </script><body><aside aria-label="Sidebar" id="sidebar" class="d-flex flex-column align-items-end"><header class="profile-wrapper"> <a href="/" id="avatar" class="rounded-circle"> <img src="/assets/link.jpg" width="112" height="112" alt="avatar" onerror="this.style.display='none'"> </a><h1 class="site-title"> <a href="/">HANABI</a></h1><p class="site-subtitle fst-italic mb-0">可乐说自己是好猫</p></header><nav class="flex-column flex-grow-1 w-100 ps-0"><ul class="nav"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive"></i> <span>归档</span> </a><li class="nav-item"> <a href="/read/" class="nav-link"> <i class="fa-fw fas fa-book-reader"></i> <span>札记</span> </a></ul></nav><div class="sidebar-bottom d-flex flex-wrap align-items-center w-100"> <button type="button" class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/KamenRiderKuuga" aria-label="github" target="_blank" rel="noopener noreferrer" > <i class="fab fa-github-alt"></i> </a> <a href="javascript:location.href = 'mailto:' + ['wpfmaker','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></aside><div id="main-wrapper" class="d-flex justify-content-center"><div class="container d-flex flex-column px-xxl-5"><header id="topbar-wrapper" aria-label="Top Bar"><div id="topbar" class="d-flex align-items-center justify-content-between px-lg-3 h-100" ><nav id="breadcrumb" aria-label="Breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>.NET Core前后端分离(5) - IOC(控制反转)与DI(依赖注入)</span></nav><button type="button" id="sidebar-trigger" class="btn btn-link"> <i class="fas fa-bars fa-fw"></i> </button><div id="topbar-title"> 文章</div><button type="button" id="search-trigger" class="btn btn-link"> <i class="fas fa-search fa-fw"></i> </button> <search class="align-items-center ms-3 ms-lg-0"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..." > </search> <button type="button" class="btn btn-link text-decoration-none" id="search-cancel">取消</button></div></header><div class="row flex-grow-1"><main aria-label="Main Content" class="col-12 col-lg-11 col-xl-9 px-md-4"><article class="px-1"><header><h1 data-toc-skip>.NET Core前后端分离(5) - IOC(控制反转)与DI(依赖注入)</h1><div class="post-meta text-muted"> <span> 发表于 <time data-ts="1592582400" data-df="YYYY/MM/DD" data-bs-toggle="tooltip" data-bs-placement="bottom" > 2020/06/20 </time> </span><div class="d-flex justify-content-between"> <span> 作者 <em> <a href=""></a> </em> </span> <span class="readtime" data-bs-toggle="tooltip" data-bs-placement="bottom" title="3904 字" > <em>21 分钟</em>阅读</span></div></div></header><div class="content"><blockquote><p>准备好了所有的层，那么要如何办到在各个<em>Service</em>层中直接调用<em>IRepository</em>层，并控制调用的仓储层实例的生命周期呢，之前写在各构造函数中的参数是如何获得的呢，让我们来了解IoC(Inversion of Control)以及DI(Dependence Injection)这两个概念</p></blockquote><h2 id="ioc控制反转思想"><span class="me-2">IoC(控制反转)思想</span><a href="#ioc控制反转思想" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。</p></blockquote><h3 id="为什么需要控制反转"><span class="me-2">为什么需要控制反转</span><a href="#为什么需要控制反转" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>先从工厂模式开始</strong></p><p>我们这里来写一段代码，定义一个小猫接口类，用几种不同的小猫类来实现这个接口，并且在调用程序用，动态的根据一个字符串的值，决定要用定义哪个小猫类，并且调用其发出叫声的函数</p><p>首先定义小猫接口<code class="language-plaintext highlighter-rouge">ICat</code>，其包含一个猫叫函数：</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">interface</span> <span class="nc">ICat</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Meow</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接着定义<code class="language-plaintext highlighter-rouge">Cats</code>类，里面包含三种不同类型的猫，并且都实现了<code class="language-plaintext highlighter-rouge">ICat</code>接口：</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Cats</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">BlackCat</span> <span class="p">:</span> <span class="n">ICat</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Meow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"I'm </span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">BlackCat</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">WhiteCat</span> <span class="p">:</span> <span class="n">ICat</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Meow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"I'm </span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">WhiteCat</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">PinkCat</span> <span class="p">:</span> <span class="n">ICat</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Meow</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"I'm </span><span class="p">{</span><span class="k">nameof</span><span class="p">(</span><span class="n">PinkCat</span><span class="p">)}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，我们对其进行调用，调用的代码是这样写的</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">strCatName</span> <span class="p">=</span> <span class="s">"BlackCat"</span><span class="p">;</span>

        <span class="n">ICat</span> <span class="n">cat</span> <span class="p">=</span> <span class="n">strCatName</span> <span class="k">switch</span>
        <span class="p">{</span>
            <span class="s">"BlackCat"</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Cats</span><span class="p">.</span><span class="nf">BlackCat</span><span class="p">(),</span>
            <span class="s">"WhiteCat"</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Cats</span><span class="p">.</span><span class="nf">WhiteCat</span><span class="p">(),</span>
            <span class="s">"PinkCat"</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Cats</span><span class="p">.</span><span class="nf">PinkCat</span><span class="p">(),</span>
            <span class="n">_</span> <span class="p">=&gt;</span> <span class="k">null</span>
        <span class="p">};</span>

        <span class="n">cat</span><span class="p">.</span><span class="nf">Meow</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>可以看到，此时采用的是在调用的地方来对具体对象进行初始化，这样做的缺点是什么呢，显而易见，这里的代码不符合<em>对修改关闭</em>的设计原则，虽然使用了接口，但是还是在实现业务功能的代码中初始化了好几种具体的类，如果需要增加或删除任何猫咪的种类，将不得不对这一段代码做出调整，并且如果其它地方需要使用的话，不具有可复用性</p><p>所以，我们创建一个新的类，将这个根据字符串获取具体类的方法放进去</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">CatFactory</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">ICat</span> <span class="nf">CreateCat</span><span class="p">(</span><span class="kt">string</span> <span class="n">strCatName</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ICat</span> <span class="n">cat</span> <span class="p">=</span> <span class="n">strCatName</span> <span class="k">switch</span>
        <span class="p">{</span>
            <span class="s">"BlackCat"</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Cats</span><span class="p">.</span><span class="nf">BlackCat</span><span class="p">(),</span>
            <span class="s">"WhiteCat"</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Cats</span><span class="p">.</span><span class="nf">WhiteCat</span><span class="p">(),</span>
            <span class="s">"PinkCat"</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">Cats</span><span class="p">.</span><span class="nf">PinkCat</span><span class="p">(),</span>
            <span class="n">_</span> <span class="p">=&gt;</span> <span class="k">null</span>
        <span class="p">};</span>

        <span class="k">return</span> <span class="n">cat</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>之后，再对其进行调用</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">strCatName</span> <span class="p">=</span> <span class="s">"BlackCat"</span><span class="p">;</span>
        <span class="n">ICat</span> <span class="n">cat</span> <span class="p">=</span> <span class="n">CatFactory</span><span class="p">.</span><span class="nf">CreateCat</span><span class="p">(</span><span class="n">strCatName</span><span class="p">);</span> 
        <span class="n">cat</span><span class="p">.</span><span class="nf">Meow</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在这里，<em>工厂</em>的概念就产生了，可以看到，我们无论在哪里需要根据字符串获取到具体的小猫类时，都可以使用这个静态的工厂类，(注意，这里实现的只是一个简单的工厂类，不是完整的工厂模式，不过可以从中体会到工厂模式的思想)</p><p><strong>体会从最开始的模式到工厂模式的变化</strong></p><p>对于调用者来说，最开始的模式中，为了得到一个具体的小猫类，我们要需要自己描述小猫的外观，自己定义产生小猫的方法，最后才得到一个心仪的小猫类。而到了工厂模式，对于调用者来说，则只需要描述小猫的外观，由工厂那边代为处理，最后就能得到自己想要的结果，获取小猫的具体过程，不需要自己操心。</p><p>在前后两种模式的变化中，可以看到我们获取小猫的过程的<strong>控制权已经发生了转移</strong>，可以理解为交给了一个专业的工厂去处理这个过程，即使我们仍然需要通过调用工厂类，来达到我们的目的，但是这样做，已经让代码耦合性降低了，至于工厂类的出现让代码的职责划分得更加明确，加强了通用性就更加不必说了。</p><p><strong>如何达到真正的控制反转呢</strong></p><p>来看一段项目中使用了依赖注入中的构造函数注入的代码：</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">readonly</span> <span class="n">SqlSugarClient</span> <span class="n">_db</span><span class="p">;</span>

<span class="k">public</span> <span class="nf">BaseRepository</span><span class="p">(</span><span class="n">IUnitOfWork</span> <span class="n">unitOfWork</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">_db</span> <span class="p">=</span> <span class="n">unitOfWork</span><span class="p">.</span><span class="nf">GetDbClient</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// &lt;summary&gt;</span>
<span class="c1">/// 写入实体数据</span>
<span class="c1">/// &lt;/summary&gt;</span>
<span class="c1">/// &lt;param name="model"&gt;实体类&lt;/param&gt;</span>
<span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="nf">Add</span><span class="p">(</span><span class="n">TEntity</span> <span class="n">model</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">insert</span> <span class="p">=</span> <span class="n">_db</span><span class="p">.</span><span class="nf">Insertable</span><span class="p">(</span><span class="n">model</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">insert</span><span class="p">.</span><span class="nf">ExecuteReturnIdentityAsync</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在使用这个<em>BaseRepository</em>类的时候，我们不需要手动去初始化<em>unitOfWork</em>，而是在代码走到其构造函数之前，已经得到了<em>unitOfWork</em>，进而得到<em>_db</em>来与数据库交互</p><p>是不是非常不可思议，就好像是小说里面的人物，心里想着一把兵器，兵器就自己出现在他手上。在类的内部函数中，没有任何一个对于要使用的类的实例化过程，兵器不是自己造的，也不是在要用到的时候委托别人去造的，更像是有人知道他需要这把兵器，就直接把这把兵器给他了。兵器的存在早于使用者自身的存在，这才是真正的，达到了控制反转</p><h2 id="di依赖注入"><span class="me-2">DI(依赖注入)</span><a href="#di依赖注入" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>通过上文我们也知道了，依赖注入是实现控制反转的一种方式，上文也展示了其使用的效果，但是描述得非常玄幻，那么实际上，依赖注入是怎么实现的呢</p><p>其实，在介绍控制反转时开头引用的那段概念，已经可以很好的说明依赖注入的实现方式了，即： <em>通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递(注入)给它。</em></p><p><strong>在我们.NET Core Web框架中，是如何实现这一点的呢</strong>，这里我们介绍<em>.NET Core</em>中两种依赖注入的方式</p><ol><li>通过调用原生框架自带的依赖注入方法</ol><p>上面提到了，依赖注入是由一个调控系统内所有对象的外界实体来完成的，这个实体在<em>.NET Core</em>框架中以容器的形式被提供，首先，查看<em>Program.cs</em>中的<em>CreateHostBuilder</em>函数</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">static</span> <span class="n">IHostBuilder</span> <span class="nf">CreateHostBuilder</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="n">Host</span><span class="p">.</span><span class="nf">CreateDefaultBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">ConfigureWebHostDefaults</span><span class="p">(</span><span class="n">webBuilder</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">webBuilder</span><span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;();</span>
        <span class="p">});</span>
</pre></table></code></div></div><p>这里调用了<em>UseStartup</em>，然后我们看到<em>Startup.cs</em>中的<em>ConfigureServices</em>函数，这个函数的官方介绍是<em>This method gets called by the runtime. Use this method to add services to the container.</em>，可以看出，这个方法是在运行时被调用，用来往容器中添加服务</p><p>没错，这里提到的容器，就是用来实现我们依赖注入的容器，这里要做的，就是在构建这个容器的时候，往里面添加我们需要用到的被注入的类就行了，我们直接用代码来说明，这里借鉴了<a href="https://stackoverflow.com/questions/38138100/addtransient-addscoped-and-addsingleton-services-differences">Stack Overflow</a>上一个答案的写法</p><p>为了更好的展示，这里新建一个<em>API</em>项目，然后新建一个接口<em>ICounter</em>，随后定义几个接口，继承<em>ICounter</em></p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="nn">WebLab.Interfaces</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">ICounter</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">GetCount</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">interface</span> <span class="nc">ICounterTransient</span> <span class="p">:</span> <span class="n">ICounter</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">interface</span> <span class="nc">ICounterScoped</span> <span class="p">:</span> <span class="n">ICounter</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">interface</span> <span class="nc">ICounterSingleton</span> <span class="p">:</span> <span class="n">ICounter</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>接着，定义一个<em>Counter</em>类，实现这几个接口</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">WebLab.Interfaces</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">WebLab.Classes</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">Counter</span> <span class="p">:</span> <span class="n">ICounterTransient</span><span class="p">,</span> <span class="n">ICounterScoped</span><span class="p">,</span> <span class="n">ICounterSingleton</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">_intCount</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">Counter</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_intCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">GetCount</span> <span class="p">=&gt;</span> <span class="n">_intCount</span><span class="p">++;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>打开<em>Startup.cs</em>文件，编辑<em>ConfigureServices</em>函数的内容，编辑过后的代码是这样的：</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddTransient</span><span class="p">&lt;</span><span class="n">ICounterTransient</span><span class="p">,</span> <span class="n">Counter</span><span class="p">&gt;();</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddScoped</span><span class="p">&lt;</span><span class="n">ICounterScoped</span><span class="p">,</span> <span class="n">Counter</span><span class="p">&gt;();</span>
    <span class="n">services</span><span class="p">.</span><span class="n">AddSingleton</span><span class="p">&lt;</span><span class="n">ICounterSingleton</span><span class="p">,</span> <span class="n">Counter</span><span class="p">&gt;();</span>

    <span class="n">services</span><span class="p">.</span><span class="nf">AddControllers</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>新建一个<em>CounterService</em>类，在这里注入我们在<em>ConfigureServices</em>中添加的接口，这里注入的对象都用<em>public</em>来修饰，确保之后可以在外部访问到</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">WebLab.Interfaces</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">WebLab.Services</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">CounterService</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">CounterService</span><span class="p">(</span><span class="n">ICounterTransient</span> <span class="n">counterTransient</span><span class="p">,</span> <span class="n">ICounterScoped</span> <span class="n">counterScoped</span><span class="p">,</span> <span class="n">ICounterSingleton</span> <span class="n">counterSingleton</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">CounterTransient</span> <span class="p">=</span> <span class="n">counterTransient</span><span class="p">;</span>
            <span class="n">CounterScoped</span> <span class="p">=</span> <span class="n">counterScoped</span><span class="p">;</span>
            <span class="n">CounterSingleton</span> <span class="p">=</span> <span class="n">counterSingleton</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">ICounterTransient</span> <span class="n">CounterTransient</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">ICounterScoped</span> <span class="n">CounterScoped</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">ICounterSingleton</span> <span class="n">CounterSingleton</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后，将这个类也添加到<em>ConfigureServices</em></p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">services</span><span class="p">.</span><span class="n">AddTransient</span><span class="p">&lt;</span><span class="n">CounterService</span><span class="p">&gt;();</span>
</pre></table></code></div></div><p>最后，定义我们的<em>CounterController</em>类，用于待会儿访问接口，查看结果</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Mvc</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">WebLab.Interfaces</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">WebLab.Services</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">WebLab.Controllers</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">ApiController</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">Route</span><span class="p">(</span><span class="s">"[controller]"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">CounterController</span> <span class="p">:</span> <span class="n">ControllerBase</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICounterTransient</span> <span class="n">_counterTransient</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICounterScoped</span> <span class="n">_counterScoped</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICounterSingleton</span> <span class="n">_counterSingleton</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">CounterService</span> <span class="n">_counterService</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">CounterController</span><span class="p">(</span><span class="n">ICounterTransient</span> <span class="n">counterTransient</span><span class="p">,</span> <span class="n">ICounterScoped</span> <span class="n">counterScoped</span><span class="p">,</span> <span class="n">ICounterSingleton</span> <span class="n">counterSingleton</span><span class="p">,</span> <span class="n">CounterService</span> <span class="n">counterService</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_counterTransient</span> <span class="p">=</span> <span class="n">counterTransient</span><span class="p">;</span>
            <span class="n">_counterScoped</span> <span class="p">=</span> <span class="n">counterScoped</span><span class="p">;</span>
            <span class="n">_counterSingleton</span> <span class="p">=</span> <span class="n">counterSingleton</span><span class="p">;</span>
            <span class="n">_counterService</span> <span class="p">=</span> <span class="n">counterService</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">[</span><span class="n">HttpGet</span><span class="p">]</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Get</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">string</span> <span class="n">strResult</span> <span class="p">=</span> <span class="s">""</span><span class="p">;</span>
            <span class="kt">string</span> <span class="n">strNewLine</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">;</span>

            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Transient:</span><span class="p">{</span><span class="n">_counterTransient</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Scoped:</span><span class="p">{</span><span class="n">_counterScoped</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Singleton:</span><span class="p">{</span><span class="n">_counterSingleton</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>

            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Transient:</span><span class="p">{</span><span class="n">_counterService</span><span class="p">.</span><span class="n">CounterTransient</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Scoped:</span><span class="p">{</span><span class="n">_counterService</span><span class="p">.</span><span class="n">CounterScoped</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Singleton:</span><span class="p">{</span><span class="n">_counterService</span><span class="p">.</span><span class="n">CounterSingleton</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">strResult</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>运行项目，通过请求http://localhost:5000/counter来查看返回的结果</p><p>第一次请求：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Transient:0
Scoped:0
Singleton:0
Transient:0
Scoped:1
Singleton:1
</pre></table></code></div></div><p>第二次请求：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>Transient:0
Scoped:0
Singleton:2
Transient:0
Scoped:1
Singleton:3
</pre></table></code></div></div><p>现在我们了解了如何使用原生框架的依赖注入，可以看到使用构造函数注入过后，只需要直接在调用者的构造函数里面加上需要的被注入的类就行了，是不是非常方便呢</p><p>同时，也让我们体会了关于依赖注入另一个非常重要的内容，<strong>生命周期</strong>，通过观察上面的结果，可以总结出注入的生命周期分三种：</p><div class="table-wrapper"><table><thead><tr><th>注入类型<th>生命周期<tbody><tr><td>Transient<td>每个请求者得到的实例都是不一样的，每次涉及到注入的时候都会提供一个全新的实例<tr><td>Scoped<td>在单次http请求中，得到的实例是一样的，在发起新的请求时，才会又提供新的实例<tr><td>Singleton<td>在整个程序运行的生命周期内，得到的实例都是同一个</table></div><ol><li>使用<em>Autofac</em>实现依赖注入</ol><p>为了体现Autofac的优势，我们先调整项目结构</p><p><a href="/assets/img/dotnetcore-9.JPG" class="popup img-link shimmer"><img src="/assets/img/dotnetcore-9.JPG" alt="" loading="lazy"></a></p><p>创建了一个<em>IService</em>层，来容纳之前的<em>ICounter</em>接口，再创建一个<em>Service</em>层，容纳具体类<em>Counter</em>，另外，去掉了刚刚为了演示生命周期创建的<em>CounterService</em>类，现在的<em>CounterController</em>类的内容为</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">Microsoft.AspNetCore.Mvc</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">WebLab.Interfaces</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">WebLab.Controllers</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">ApiController</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">Route</span><span class="p">(</span><span class="s">"[controller]"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">CounterController</span> <span class="p">:</span> <span class="n">ControllerBase</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICounterTransient</span> <span class="n">_counterTransient</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICounterScoped</span> <span class="n">_counterScoped</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">ICounterSingleton</span> <span class="n">_counterSingleton</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">CounterController</span><span class="p">(</span><span class="n">ICounterTransient</span> <span class="n">counterTransient</span><span class="p">,</span> <span class="n">ICounterScoped</span> <span class="n">counterScoped</span><span class="p">,</span> <span class="n">ICounterSingleton</span> <span class="n">counterSingleton</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_counterTransient</span> <span class="p">=</span> <span class="n">counterTransient</span><span class="p">;</span>
            <span class="n">_counterScoped</span> <span class="p">=</span> <span class="n">counterScoped</span><span class="p">;</span>
            <span class="n">_counterSingleton</span> <span class="p">=</span> <span class="n">counterSingleton</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">[</span><span class="n">HttpGet</span><span class="p">]</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Get</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">string</span> <span class="n">strResult</span> <span class="p">=</span> <span class="s">""</span><span class="p">;</span>
            <span class="kt">string</span> <span class="n">strNewLine</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">NewLine</span><span class="p">;</span>

            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Transient:</span><span class="p">{</span><span class="n">_counterTransient</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Scoped:</span><span class="p">{</span><span class="n">_counterScoped</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
            <span class="n">strResult</span> <span class="p">+=</span> <span class="s">$"Singleton:</span><span class="p">{</span><span class="n">_counterSingleton</span><span class="p">.</span><span class="n">GetCount</span><span class="p">}{</span><span class="n">strNewLine</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">strResult</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>此时，怎么进行依赖注入呢，首先，在<em>WebLab</em>项目中引入包<em>Autofac.Extensions.DependencyInjection</em>，这个是<em>Autofac</em>用于依赖注入的包，之后，修改<em>Program.cs</em>文件的<em>CreateHostBuilder</em>函数</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">static</span> <span class="n">IHostBuilder</span> <span class="nf">CreateHostBuilder</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="n">Host</span><span class="p">.</span><span class="nf">CreateDefaultBuilder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">UseServiceProviderFactory</span><span class="p">(</span><span class="k">new</span> <span class="nf">AutofacServiceProviderFactory</span><span class="p">())</span>
        <span class="p">.</span><span class="nf">ConfigureWebHostDefaults</span><span class="p">(</span><span class="n">webBuilder</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="n">webBuilder</span><span class="p">.</span><span class="n">UseStartup</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;();</span>
        <span class="p">});</span>
</pre></table></code></div></div><p>可以看到，这里增加了一句<code class="language-plaintext highlighter-rouge">.UseServiceProviderFactory(new AutofacServiceProviderFactory())</code>，这代表我们会用<em>Autofac</em>来注入一些服务，此时切换到<em>Startup.cs</em>文件，增加函数</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureContainer</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">builder</span><span class="p">.</span><span class="nf">RegisterModule</span><span class="p">(</span><span class="k">new</span> <span class="nf">AutofacModuleRegister</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p><em>AutofacModuleRegister.cs</em>文件的内容：</p><div class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="C#"><i class="fas fa-code fa-fw small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="nn">Autofac</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.IO</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">System.Reflection</span><span class="p">;</span>

<span class="k">namespace</span> <span class="nn">WebLab</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">AutofacModuleRegister</span> <span class="p">:</span> <span class="n">Autofac</span><span class="p">.</span><span class="n">Module</span>
    <span class="p">{</span>
        <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Load</span><span class="p">(</span><span class="n">ContainerBuilder</span> <span class="n">builder</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">basePath</span> <span class="p">=</span> <span class="n">AppContext</span><span class="p">.</span><span class="n">BaseDirectory</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">servicesDllFile</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span><span class="n">basePath</span><span class="p">,</span> <span class="s">"WebLab.Service.dll"</span><span class="p">);</span>

            <span class="c1">// 获取 WebLab.Service.dll 程序集服务，并注册      </span>
            <span class="kt">var</span> <span class="n">assemblysServices</span> <span class="p">=</span> <span class="n">Assembly</span><span class="p">.</span><span class="nf">LoadFrom</span><span class="p">(</span><span class="n">servicesDllFile</span><span class="p">);</span>
            
            <span class="n">builder</span><span class="p">.</span><span class="nf">RegisterAssemblyTypes</span><span class="p">(</span><span class="n">assemblysServices</span><span class="p">)</span>
                      <span class="p">.</span><span class="nf">AsImplementedInterfaces</span><span class="p">()</span>
                      <span class="p">.</span><span class="nf">InstancePerDependency</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>到目前为止，通过<em>Autofac</em>进行依赖注入的过程就完成了，可以看到<em>Autofac</em>通过反射获取到程序集，再进行批量注入，这里是直接注入了<em>WebLab.Service.dll</em>，并通过使用方法<code class="language-plaintext highlighter-rouge">AsImplementedInterfaces()</code>，<strong>将程序集中的类型作为对应接口的具体实现类注入了程序集中所有类型的公共接口(IDisposable除外)</strong>，所以之后在程序的任何地方，都可以直接使用被注入的接口</p><p>注意这里的<code class="language-plaintext highlighter-rouge">InstancePerDependency</code>是对标原生注入方法中的<code class="language-plaintext highlighter-rouge">AddTransient</code>，另外还能选择<code class="language-plaintext highlighter-rouge">InstancePerLifetimeScope</code>和<code class="language-plaintext highlighter-rouge">SingleInstance</code>，分别对应原生注入中的<code class="language-plaintext highlighter-rouge">AddScoped</code>和<code class="language-plaintext highlighter-rouge">AddSingleton</code></p><p>最后我们运行程序，却发现在注册服务的时候出现了错误提示，这是为什么呢</p><p><a href="/assets/img/dotnetcore-10.JPG" class="popup img-link shimmer"><img src="/assets/img/dotnetcore-10.JPG" alt="" loading="lazy"></a></p><p>观察项目结构不难发现，我们现在的<em>WebLab</em>项目在<em>Controller</em>内已经是完全在调用接口了，和<em>WebLab.Service</em>项目已经完全解耦了，所以在作为启动项启动时，不会将<em>WebLab.Service</em>编译到程序启动目录，所以这里就不能正常注入了，于是我们调整<em>WebLab.Service</em>项目的生成路径，在项目属性-生成-输出-输出路径中将其生成路径调整到<em>WebLab</em>生成路径，这里使用相对路径</p><p><a href="/assets/img/dotnetcore-11.JPG" class="popup img-link shimmer"><img src="/assets/img/dotnetcore-11.JPG" alt="" loading="lazy"></a></p><p>再次生成解决方案，运行项目，项目正确启动了，对接口进行请求，因为这里采用的是<em>Transient</em>注入，所以每次都会请求到相同的内容，可以感受到，当项目结构清晰，相似功能的接口较多的时候，利用<em>Autofac</em>进行批量依赖注入是非常方便的，使用很短的代码就可以实现需求</p><h2 id="总结"><span class="me-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>依赖注入和工厂模式，都有效的解决了项目耦合度高，业务代码被入侵的问题。依赖注入，可以说通过容器这个“第三方”完成了以前工厂模式做的事情，并且更进一步的，让获取新实例的代码从实际业务代码函数中不可见，使代码层次更加清晰，真正达到了控制反转的目的。同时，其还能让我们更方便管理实例的生命周期</p><p>PS:文中用到的注入都是根据具体的实现类，对接口进行注入，达到了面向接口编程的目的，依赖注入的方法不局限于这样，也可以直接对具体的类或者对象实例进行注入，写法和用法相对容易理解，就不举例说明了</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw me-1"></i> <a href="/categories/%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6/">编程框架</a>, <a href="/categories/asp-net-core/">ASP.NET Core</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw me-1"></i> <a href="/tags/net-core/" class="post-tag no-text-decoration" >.NET Core</a></div><div class=" post-tail-bottom d-flex justify-content-between align-items-center mt-5 pb-2 " ><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper d-flex align-items-center"> <span class="share-label text-muted me-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=.NET%20Core%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB(5)%20-%20IOC(%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)%E4%B8%8EDI(%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)%20-%20HANABI&url=https%3A%2F%2Flambda.cyou%2F%2Fposts%2Fdotnetcore-6%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter" > <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=.NET%20Core%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB(5)%20-%20IOC(%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)%E4%B8%8EDI(%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)%20-%20HANABI&u=https%3A%2F%2Flambda.cyou%2F%2Fposts%2Fdotnetcore-6%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook" > <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=.NET%20Core%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB(5)%20-%20IOC(%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)%E4%B8%8EDI(%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5)%20-%20HANABI&url=https%3A%2F%2Flambda.cyou%2F%2Fposts%2Fdotnetcore-6%2F" data-bs-toggle="tooltip" data-bs-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram" > <i class="fa-fw fab fa-telegram"></i> </a> <button id="copy-link" aria-label="Copy link" class="btn small" data-bs-toggle="tooltip" data-bs-placement="top" title="分享链接" data-title-succeed="链接已复制！" > <i class="fa-fw fas fa-link pe-none"></i> </button> </span></div></div></div></article></main><aside aria-label="Panel" id="panel-wrapper" class="col-xl-3 ps-2 mb-5 text-muted"><div class="access"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/net-core/">.NET Core</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">Python</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%8A%80%E6%9C%AF%E5%A4%87%E5%BF%98/">技术备忘</a> <a class="post-tag btn btn-outline-primary" href="/tags/css/">CSS</a> <a class="post-tag btn btn-outline-primary" href="/tags/html/">HTML</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">Rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/">日常工具</a> <a class="post-tag btn btn-outline-primary" href="/tags/dbms/">DBMS</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">Docker</a></div></section></div><section id="toc-wrapper" class="ps-0 pe-4"><h2 class="panel-heading ps-3 pt-2 mb-2">文章内容</h2><nav id="toc"></nav></section></aside></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 px-md-4"><aside id="related-posts" aria-labelledby="related-label"><h3 class="mb-4" id="related-label">相关文章</h3><nav class="row row-cols-1 row-cols-md-2 row-cols-xl-3 g-4 mb-4"><article class="col"> <a href="/posts/dotnetcore-1/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1591200000" data-df="YYYY/MM/DD" > 2020/06/04 </time><h4 class="pt-0 my-2">部署Vue+.NET Core前后端分离项目中遇到的问题</h4><div class="text-muted"><p> 这里记录一些在部署项目过程中容易忘记的点，主要做备忘用 Nginx 1.双击之后一闪而过 这个是在Windows中使用的时候出现的，双击nginx.exe之后一闪而过，打开任务管理器也没有相关进程，在浏览器中输入localhost也无法访问欢迎页面，检查之后才知道是因为nginx所在路径存在中文，换了没有中文的路径之后启动，没有出现此问题 2.配置vue项目后刷新后出现404...</p></div></div></a></article><article class="col"> <a href="/posts/dotnetcore-2/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1591891200" data-df="YYYY/MM/DD" > 2020/06/12 </time><h4 class="pt-0 my-2">.NET Core前后端分离(1) - Swagger的使用</h4><div class="text-muted"><p> 在前后端分离过程中,API文档是非常重要的,在项目搭建的第一步,我们使用Swagger来实现这一点 引入Nuget包 在项目中安装Swashbuckle.AspNetCore.SwaggerGen和Swashbuckle.AspNetCore.SwaggerUI 配置服务 在Startup.cs文件的ConfigureServices函数中添加服务: // 类中定义常量,方...</p></div></div></a></article><article class="col"> <a href="/posts/dotnetcore-3/" class="post-preview card h-100"><div class="card-body"> <time data-ts="1591977600" data-df="YYYY/MM/DD" > 2020/06/13 </time><h4 class="pt-0 my-2">.NET Core前后端分离(2) - 配置文件与变量</h4><div class="text-muted"><p> 在代码中，为了避免代码复用，以及在没有编译条件时能调整程序内部的一些设置，常常需要有一个配置中心，方便快速更改整个程序的全局变量，所以我们先来编写好配置中心的相关代码 在代码中编写全局变量的一些方法 使用定义全局静态类，添加静态变量，方便修改，全局可用 采用依赖注入的方式在项目中注入一个Singleton的变量，使其在整个项目周期中都可以使用 这两种，都是直接写在代...</p></div></div></a></article></nav></aside><nav class="post-navigation d-flex justify-content-between" aria-label="Post Navigation"> <a href="/posts/sql-1/" class="btn btn-outline-primary" aria-label="上一篇" ><p>LeetCode记录(SQL)(普通题)</p></a> <a href="/posts/foundation-1/" class="btn btn-outline-primary" aria-label="下一篇" ><p>地基系列 - 引言</p></a></nav><footer aria-label="Site Info" class=" d-flex flex-column justify-content-center text-muted flex-lg-row justify-content-lg-between align-items-lg-center pb-lg-3 " ><p> © <time>2024</time> <a href="https://github.com/KamenRiderKuuga">HANABI</a>. <span data-bs-toggle="tooltip" data-bs-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。" >保留部分权利。</span></p><p>本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></footer></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-11 content"><div id="search-hints"><section><h2 class="panel-heading">热门标签</h2><div class="d-flex flex-wrap mt-3 mb-1 me-3"> <a class="post-tag btn btn-outline-primary" href="/tags/net-core/">.NET Core</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a> <a class="post-tag btn btn-outline-primary" href="/tags/python/">Python</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%8A%80%E6%9C%AF%E5%A4%87%E5%BF%98/">技术备忘</a> <a class="post-tag btn btn-outline-primary" href="/tags/css/">CSS</a> <a class="post-tag btn btn-outline-primary" href="/tags/html/">HTML</a> <a class="post-tag btn btn-outline-primary" href="/tags/rust/">Rust</a> <a class="post-tag btn btn-outline-primary" href="/tags/%E6%97%A5%E5%B8%B8%E5%B7%A5%E5%85%B7/">日常工具</a> <a class="post-tag btn btn-outline-primary" href="/tags/dbms/">DBMS</a> <a class="post-tag btn btn-outline-primary" href="/tags/docker/">Docker</a></div></section></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><aside aria-label="Scroll to Top"> <button id="back-to-top" type="button" class="btn btn-lg btn-box-shadow"> <i class="fas fa-angle-up"></i> </button></aside></div><div id="mask"></div><script src="https://cdn.jsdelivr.net/combine/npm/jquery@3.7.1/dist/jquery.min.js,npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js,npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js,npm/loading-attribute-polyfill@2.1.1/dist/loading-attribute-polyfill.umd.min.js,npm/magnific-popup@1.1.0/dist/jquery.magnific-popup.min.js,npm/clipboard@2.0.11/dist/clipboard.min.js,npm/dayjs@1.11.10/dayjs.min.js,npm/dayjs@1.11.10/locale/zh.min.js,npm/dayjs@1.11.10/plugin/relativeTime.min.js,npm/dayjs@1.11.10/plugin/localizedFormat.min.js,npm/tocbot@4.21.2/dist/tocbot.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/unregister.js"></script> <script> /* Note: dependent library will be loaded in `js-selector.html` */ SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<article class="px-1 px-sm-2 px-lg-4 px-xl-0"><header><h2><a href="{url}">{title}</a></h2><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div></header><p>{snippet}</p></article>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="me-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
